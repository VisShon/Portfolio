{"ast":null,"code":"import { useFrame as r } from \"@studio-freight/hamo\";\nimport e from \"@studio-freight/lenis\";\nimport t from \"clsx\";\nimport o from \"prop-types\";\nimport a, { createContext as n, useEffect as c, forwardRef as s, useRef as l, useState as i, useCallback as u, useImperativeHandle as f, useContext as m } from \"react\";\nimport { create as p } from \"zustand\";\nfunction d() {\n  return d = Object.assign ? Object.assign.bind() : function (r) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);\n    }\n    return r;\n  }, d.apply(this, arguments);\n}\nconst b = n(),\n  y = p(() => ({}));\nfunction h(r) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const {\n    lenis: o,\n    addCallback: a,\n    removeCallback: n\n  } = function () {\n    const r = m(b),\n      e = y();\n    return r !== null && r !== void 0 ? r : e;\n  }();\n  return c(() => {\n    if (r && a && n && o) return a(r, t), r(o), () => {\n      n(r);\n    };\n  }, [o, a, n, t, ...e]), o;\n}\nconst v = s((_ref, g) => {\n  let {\n    children: o,\n    root: n = !1,\n    options: s = {},\n    autoRaf: m = !0,\n    rafPriority: p = 0,\n    className: h,\n    ...v\n  } = _ref;\n  const N = l(),\n    k = l(),\n    [C, O] = i(),\n    j = l([]),\n    w = u((r, e) => {\n      j.current.push({\n        callback: r,\n        priority: e\n      }), j.current.sort((r, e) => r.priority - e.priority);\n    }, []),\n    P = u(r => {\n      j.current = j.current.filter(e => e.callback !== r);\n    }, []);\n  f(g, () => ({\n    wrapper: N.current,\n    content: k.current,\n    lenis: C\n  }), [C]), c(() => {\n    const r = new e({\n      ...s,\n      ...(!n && {\n        wrapper: N.current,\n        content: k.current\n      })\n    });\n    return O(r), () => {\n      r.destroy(), O(void 0);\n    };\n  }, [n, JSON.stringify(s)]), r(r => {\n    m && (C === null || C === void 0 ? void 0 : C.raf(r));\n  }, p), c(() => {\n    n && C && y.setState({\n      lenis: C,\n      addCallback: w,\n      removeCallback: P\n    });\n  }, [n, C, w, P]);\n  const E = u(r => {\n    for (let e = 0; e < j.current.length; e++) j.current[e].callback(r);\n  }, []);\n  c(() => (C !== null && C !== void 0 && C.on(\"scroll\", E), () => {\n    C === null || C === void 0 || C.off(\"scroll\", E);\n  }), [C, E]);\n  const R = u(() => {\n    N.current && (N.current.className = t(C === null || C === void 0 ? void 0 : C.className, h));\n  }, [C, h]);\n  return c(() => (R(), C !== null && C !== void 0 && C.on(\"className change\", R), () => {\n    C === null || C === void 0 || C.off(\"className change\", R);\n  }), [C, R]), a.createElement(b.Provider, {\n    value: {\n      lenis: C,\n      addCallback: w,\n      removeCallback: P\n    }\n  }, n ? o : a.createElement(\"div\", d({\n    ref: N,\n    className: t(C === null || C === void 0 ? void 0 : C.className, h)\n  }, v), a.createElement(\"div\", {\n    ref: k\n  }, o)));\n});\nv.displayName = \"ReactLenis\", v.propTypes = {\n  children: o.node,\n  root: o.bool,\n  options: o.object,\n  autoRaf: o.bool,\n  rafPriority: o.number,\n  className: o.string\n};\nexport { v as Lenis, b as LenisContext, v as ReactLenis, v as default, h as useLenis };","map":{"version":3,"names":["b","n","y","p","h","r","e","arguments","length","undefined","t","lenis","o","addCallback","a","removeCallback","m","c","v","s","_ref","g","children","root","options","autoRaf","rafPriority","className","N","l","k","C","O","i","j","w","u","current","push","callback","priority","sort","P","filter","f","wrapper","content","destroy","JSON","stringify","raf","setState","E","on","off","R","createElement","Provider","value","d","ref","displayName","propTypes","node","bool","object","number","string","Lenis","LenisContext","ReactLenis","default","useLenis"],"sources":["/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/react-lenis/src/index.jsx"],"sourcesContent":["'use client'\r\n\r\nimport { useFrame } from '@studio-freight/hamo'\r\nimport Lenis from '@studio-freight/lenis'\r\nimport cn from 'clsx'\r\nimport PropTypes from 'prop-types' // ES6\r\nimport React, {\r\n  createContext,\r\n  forwardRef,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport { create } from 'zustand'\r\n\r\nexport const LenisContext = createContext()\r\n\r\nconst useRoot = create(() => ({}))\r\n\r\nfunction useCurrentLenis() {\r\n  const local = useContext(LenisContext)\r\n  const root = useRoot()\r\n\r\n  return local ?? root\r\n}\r\n\r\n/**\r\n * @param {CallbackFunction} [callback] Callback to be called on scroll\r\n * @param {Array=} [deps=[]] Dependencies for callback\r\n * @param {number=} [priority=0] Priority of callback (lower priority callbacks are called first)\r\n *\r\n * @returns {LenisInstance} Lenis instance\r\n */\r\nexport function useLenis(callback, deps = [], priority = 0) {\r\n  const { lenis, addCallback, removeCallback } = useCurrentLenis()\r\n\r\n  useEffect(() => {\r\n    if (!callback || !addCallback || !removeCallback || !lenis) return\r\n\r\n    addCallback(callback, priority)\r\n    callback(lenis)\r\n\r\n    return () => {\r\n      removeCallback(callback)\r\n    }\r\n  }, [lenis, addCallback, removeCallback, priority, ...deps])\r\n\r\n  return lenis\r\n}\r\n\r\n/**\r\n * @param {boolean=} [root] Whether Lenis will be initialized on document.documentElement\r\n * @param {ReactLenisOptions} [options={}] Lenis options {@link ReactLenisOptions}\r\n * @param {boolean=} [autoRaf=true] Whether to call Lenis.raf automatically on every frame\r\n * @param {number=} [rafPriority=0] Priority of Lenis.raf call (lower priority callbacks are called first)\r\n * @param {string=} [className] Class name to be applied to the wrapper\r\n */\r\nconst ReactLenis = forwardRef(\r\n  (\r\n    {\r\n      children,\r\n      root = false,\r\n      options = {},\r\n      autoRaf = true,\r\n      rafPriority = 0,\r\n      className,\r\n      ...props\r\n    },\r\n    ref\r\n  ) => {\r\n    const wrapperRef = useRef()\r\n    const contentRef = useRef()\r\n\r\n    const [lenis, setLenis] = useState()\r\n\r\n    const callbacksRefs = useRef([])\r\n\r\n    const addCallback = useCallback((callback, priority) => {\r\n      callbacksRefs.current.push({ callback, priority })\r\n      callbacksRefs.current.sort((a, b) => a.priority - b.priority)\r\n    }, [])\r\n\r\n    const removeCallback = useCallback((callback) => {\r\n      callbacksRefs.current = callbacksRefs.current.filter(\r\n        (cb) => cb.callback !== callback\r\n      )\r\n    }, [])\r\n\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        wrapper: wrapperRef.current,\r\n        content: contentRef.current,\r\n        lenis,\r\n      }),\r\n      [lenis]\r\n    )\r\n\r\n    useEffect(() => {\r\n      const lenis = new Lenis({\r\n        ...options,\r\n        ...(!root && {\r\n          wrapper: wrapperRef.current,\r\n          content: contentRef.current,\r\n        }),\r\n      })\r\n\r\n      setLenis(lenis)\r\n\r\n      return () => {\r\n        lenis.destroy()\r\n        setLenis(undefined)\r\n      }\r\n    }, [root, JSON.stringify(options)])\r\n\r\n    useFrame((time) => {\r\n      if (autoRaf) {\r\n        lenis?.raf(time)\r\n      }\r\n    }, rafPriority)\r\n\r\n    useEffect(() => {\r\n      if (root && lenis) {\r\n        useRoot.setState({ lenis, addCallback, removeCallback })\r\n      }\r\n    }, [root, lenis, addCallback, removeCallback])\r\n\r\n    const onScroll = useCallback((e) => {\r\n      for (let i = 0; i < callbacksRefs.current.length; i++) {\r\n        callbacksRefs.current[i].callback(e)\r\n      }\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n      lenis?.on('scroll', onScroll)\r\n\r\n      return () => {\r\n        lenis?.off('scroll', onScroll)\r\n      }\r\n    }, [lenis, onScroll])\r\n\r\n    const onClassNameChange = useCallback(() => {\r\n      if (wrapperRef.current)\r\n        wrapperRef.current.className = cn(lenis?.className, className)\r\n    }, [lenis, className])\r\n\r\n    useEffect(() => {\r\n      onClassNameChange()\r\n\r\n      lenis?.on('className change', onClassNameChange)\r\n\r\n      return () => {\r\n        lenis?.off('className change', onClassNameChange)\r\n      }\r\n    }, [lenis, onClassNameChange])\r\n\r\n    return (\r\n      <LenisContext.Provider value={{ lenis, addCallback, removeCallback }}>\r\n        {root ? (\r\n          children\r\n        ) : (\r\n          <div\r\n            ref={wrapperRef}\r\n            className={cn(lenis?.className, className)}\r\n            {...props}\r\n          >\r\n            <div ref={contentRef}>{children}</div>\r\n          </div>\r\n        )}\r\n      </LenisContext.Provider>\r\n    )\r\n  }\r\n)\r\nReactLenis.displayName = 'ReactLenis'\r\n\r\nReactLenis.propTypes = {\r\n  children: PropTypes.node,\r\n  root: PropTypes.bool,\r\n  options: PropTypes.object,\r\n  autoRaf: PropTypes.bool,\r\n  rafPriority: PropTypes.number,\r\n  className: PropTypes.string,\r\n}\r\n\r\nexport { ReactLenis as Lenis, ReactLenis }\r\nexport default ReactLenis\r\n\r\n/**\r\n * @callback EasingFunction\r\n * @param {number} rawValue\r\n * @returns {number} eased output value\r\n */\r\n\r\n/**\r\n * @callback CallbackFunction\r\n * @param {LenisInstance} instance\r\n */\r\n\r\n/**\r\n * @typedef {Object} CallbackEvents\r\n * @property {CallbackFunction[]} scroll scroll events\r\n */\r\n\r\n/**\r\n * @callback RAF\r\n * @param {number} time\r\n */\r\n\r\n/**\r\n * @typedef {Object} ScrollToParams\r\n * @property {number} [offset] equivalent to scroll-padding-top\r\n * @property {number} [lerp] animation interpolation rate\r\n * @property {number} [duration] animation duration (in seconds)\r\n * @property {EasingFunction} [easing] animation easing\r\n * @property {boolean} [immediate] ignore duration, easing and lerp\r\n * @property {boolean} [lock] whether or not to prevent the user from scrolling until the target is reached\r\n * @property {boolean} [force] reach target even if instance is stopped\r\n * @property {CallbackFunction} [onComplete] called when the target is reached\r\n */\r\n\r\n/**\r\n * @callback ScrollTo\r\n * @param {number|string|HTMLElement} target\r\n * @param {ScrollToParams} [options]\r\n */\r\n\r\n/**\r\n * @typedef {Object} ReactLenisOptions\r\n * @property {(HTMLElement|Window)} [wrapper=window] interpolation rate\r\n * @property {HTMLElement=} [content=document.documentElement]\r\n * @property {(HTMLElement|Window)} [wheelEventsTarget=wrapper]\r\n * @property {number=} [lerp=0.1] interpolation rate\r\n * @property {number=} [duration=1.2] scroll duration\r\n * @property {EasingFunction=} [easing=(t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))] // easing function to apply to scroll values\r\n * @property {string=} [orientation='vertical'] scroll orientation\r\n * @property {string=} [gestureOrientation='vertical']\r\n * @property {boolean=} [smoothWheel=true]\r\n * @property {boolean=} [smoothTouch=false]\r\n * @property {boolean=} [syncTouch=false]\r\n * @property {number=} [syncTouchLerp=0.1]\r\n * @property {number=} [touchInertiaMultiplier=1]\r\n * @property {boolean=} [normalizeWheel=false]\r\n * @property {boolean=} [infinite=false] enable infinite scroll\r\n * @property {boolean=} [autoResize=true]\r\n */\r\n\r\n/**\r\n * @typedef {Object} Dimensions\r\n * @property {(HTMLElement|Window)} wrapper Wrapper lenis is applied to\r\n * @property {HTMLElement} content\r\n * @property {ResizeObserver} contentResizeObserver\r\n * @property {function():void} resize\r\n * @property {function():void} onContentResize\r\n * @property {function():void} onWrapperResize\r\n * @property {number} width viewport width\r\n * @property {number} height viewport height\r\n * @property {number} scrollWidth\r\n * @property {number} scrollHeight\r\n */\r\n\r\n/**\r\n * @typedef {Object} Emitter\r\n * @property {CallbackEvents} events\r\n */\r\n\r\n/**\r\n * @callback EventHandler\r\n * @param {string} id lenis instance event\r\n * @param {CallbackFunction} fn callback\r\n */\r\n\r\n/**\r\n * @typedef {Object} LenisInstance\r\n * @property {number} animatedScroll Current scroll value\r\n * @property {Dimensions} dimensions Dimensions instance\r\n * @property {number} direction scroll direction; 0: stopped, 1: scrolling up, -1: scrolling down\r\n * @property {Emitter} emitter Emitter instance\r\n * @property {ReactLenisOptions} options Instance options {@link ReactLenisOptions}\r\n * @property {number} targetScroll Target scroll value\r\n * @property {number} time Time elapsed since instance creation\r\n * @property {number} actualScroll Current scroll value registered by the browser\r\n * @property {number} velocity Current scroll velocity\r\n * @property {boolean} isHorizontal Whether or not the instance is horizontal\r\n * @property {boolean} isScrolling Whether or not the instance is being animated\r\n * @property {boolean} isSmooth Whether or not the instance is animated\r\n * @property {boolean} isStopped Whether or not the user should be able to scroll\r\n * @property {number} limit Maximum scroll value\r\n * @property {number} progress Scroll progress from 0 to 1\r\n * @property {HTMLElement} rootElement Element on which Lenis is instanced\r\n * @property {number} scroll Current scroll value (handles infinite scroll if activated)\r\n * @property {function():void} stop Pauses the scroll\r\n * @property {function():void} start Resumes the scroll\r\n * @property {function():void} resize Compute internal sizes, has to be used if autoResize option is false\r\n * @property {function():void} destroy Destroys the instance and removes all events\r\n * @property {EventHandler} on Lenis event listener\r\n * @property {ScrollTo} scrollTo Scroll to target\r\n * @property {RAF} raf Must be called every frame for internal usage\r\n */\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}