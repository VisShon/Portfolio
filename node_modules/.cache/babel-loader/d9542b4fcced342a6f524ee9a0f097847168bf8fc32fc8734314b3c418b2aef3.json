{"ast":null,"code":"import _defineProperty from \"/Users/apple/Downloads/VisShon/website/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nfunction t(t, e, i) {\n  return Math.max(t, Math.min(e, i));\n}\nclass Animate {\n  advance(e) {\n    var _this$onUpdate;\n    if (!this.isRunning) return;\n    let i = !1;\n    if (this.lerp) this.value = (s = this.value, o = this.to, n = 60 * this.lerp, r = e, function (t, e, i) {\n      return (1 - i) * t + i * e;\n    }(s, o, 1 - Math.exp(-n * r))), Math.round(this.value) === this.to && (this.value = this.to, i = !0);else {\n      this.currentTime += e;\n      const s = t(0, this.currentTime / this.duration, 1);\n      i = s >= 1;\n      const o = i ? 1 : this.easing(s);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var s, o, n, r;\n    (_this$onUpdate = this.onUpdate) !== null && _this$onUpdate !== void 0 && _this$onUpdate.call(this, this.value, i), i && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, e, _ref) {\n    let {\n      lerp: i = .1,\n      duration: s = 1,\n      easing: o = t => t,\n      onStart: n,\n      onUpdate: r\n    } = _ref;\n    this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, n !== null && n !== void 0 && n(), this.onUpdate = r;\n  }\n}\nclass Dimensions {\n  constructor() {\n    let {\n      wrapper: t,\n      content: e,\n      autoResize: i = !0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"resize\", () => {\n      this.onWrapperResize(), this.onContentResize();\n    });\n    _defineProperty(this, \"onWrapperResize\", () => {\n      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n    });\n    _defineProperty(this, \"onContentResize\", () => {\n      this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n    });\n    if (this.wrapper = t, this.content = e, i) {\n      const t = function (t, e) {\n        let i;\n        return function () {\n          let s = arguments,\n            o = this;\n          clearTimeout(i), i = setTimeout(function () {\n            t.apply(o, s);\n          }, e);\n        };\n      }(this.resize, 250);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var _this$wrapperResizeOb, _this$contentResizeOb;\n    (_this$wrapperResizeOb = this.wrapperResizeObserver) !== null && _this$wrapperResizeOb !== void 0 && _this$wrapperResizeOb.disconnect(), (_this$contentResizeOb = this.contentResizeObserver) === null || _this$contentResizeOb === void 0 ? void 0 : _this$contentResizeOb.disconnect();\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass Emitter {\n  constructor() {\n    this.events = {};\n  }\n  emit(t) {\n    let i = this.events[t] || [];\n    for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      e[_key - 1] = arguments[_key];\n    }\n    for (let t = 0, s = i.length; t < s; t++) i[t](...e);\n  }\n  on(t, e) {\n    var _this$events$t;\n    return (_this$events$t = this.events[t]) !== null && _this$events$t !== void 0 && _this$events$t.push(e) || (this.events[t] = [e]), () => {\n      var _this$events$t2;\n      this.events[t] = (_this$events$t2 = this.events[t]) === null || _this$events$t2 === void 0 ? void 0 : _this$events$t2.filter(t => e !== t);\n    };\n  }\n  off(t, e) {\n    var _this$events$t3;\n    this.events[t] = (_this$events$t3 = this.events[t]) === null || _this$events$t3 === void 0 ? void 0 : _this$events$t3.filter(t => e !== t);\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass VirtualScroll {\n  constructor(_t, _ref2) {\n    let {\n      wheelMultiplier: _e = 1,\n      touchMultiplier: _i = 2,\n      normalizeWheel: _s = !1\n    } = _ref2;\n    _defineProperty(this, \"onTouchStart\", t => {\n      const {\n        clientX: e,\n        clientY: i\n      } = t.targetTouches ? t.targetTouches[0] : t;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: 0,\n        y: 0\n      }, this.emitter.emit(\"scroll\", {\n        deltaX: 0,\n        deltaY: 0,\n        event: t\n      });\n    });\n    _defineProperty(this, \"onTouchMove\", t => {\n      const {\n          clientX: e,\n          clientY: i\n        } = t.targetTouches ? t.targetTouches[0] : t,\n        s = -(e - this.touchStart.x) * this.touchMultiplier,\n        o = -(i - this.touchStart.y) * this.touchMultiplier;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: s,\n        y: o\n      }, this.emitter.emit(\"scroll\", {\n        deltaX: s,\n        deltaY: o,\n        event: t\n      });\n    });\n    _defineProperty(this, \"onTouchEnd\", t => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event: t\n      });\n    });\n    _defineProperty(this, \"onWheel\", e => {\n      let {\n        deltaX: i,\n        deltaY: s\n      } = e;\n      this.normalizeWheel && (i = t(-100, i, 100), s = t(-100, s, 100)), i *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n        deltaX: i,\n        deltaY: s,\n        event: e\n      });\n    });\n    this.element = _t, this.wheelMultiplier = _e, this.touchMultiplier = _i, this.normalizeWheel = _s, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new Emitter(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n}\nclass Lenis {\n  constructor() {\n    let {\n      wrapper: _t2 = window,\n      content: _e2 = document.documentElement,\n      wheelEventsTarget: _i2 = _t2,\n      eventsTarget: _s2 = _i2,\n      smoothWheel: _o = !0,\n      syncTouch: _n = !1,\n      syncTouchLerp: _r = .075,\n      touchInertiaMultiplier: _l = 35,\n      duration: _h,\n      easing: _a = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n      lerp: _c = !_h && .1,\n      infinite: p = !1,\n      orientation: u = \"vertical\",\n      gestureOrientation: d = \"vertical\",\n      touchMultiplier: m = 1,\n      wheelMultiplier: g = 1,\n      normalizeWheel: v = !1,\n      autoResize: S = !0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _defineProperty(this, \"onVirtualScroll\", _ref3 => {\n      let {\n        deltaX: t,\n        deltaY: e,\n        event: i\n      } = _ref3;\n      if (i.ctrlKey) return;\n      const s = i.type.includes(\"touch\"),\n        o = i.type.includes(\"wheel\");\n      if (this.options.syncTouch && s && \"touchstart\" === i.type) return void this.reset();\n      const n = 0 === t && 0 === e,\n        r = \"vertical\" === this.options.gestureOrientation && 0 === e || \"horizontal\" === this.options.gestureOrientation && 0 === t;\n      if (n || r) return;\n      let l = i.composedPath();\n      if (l = l.slice(0, l.indexOf(this.rootElement)), l.find(t => {\n        var _t$hasAttribute, _t$hasAttribute2, _t$hasAttribute3, _t$classList;\n        return ((_t$hasAttribute = t.hasAttribute) === null || _t$hasAttribute === void 0 ? void 0 : _t$hasAttribute.call(t, \"data-lenis-prevent\")) || s && ((_t$hasAttribute2 = t.hasAttribute) === null || _t$hasAttribute2 === void 0 ? void 0 : _t$hasAttribute2.call(t, \"data-lenis-prevent-touch\")) || o && ((_t$hasAttribute3 = t.hasAttribute) === null || _t$hasAttribute3 === void 0 ? void 0 : _t$hasAttribute3.call(t, \"data-lenis-prevent-wheel\")) || ((_t$classList = t.classList) === null || _t$classList === void 0 ? void 0 : _t$classList.contains(\"lenis\"));\n      })) return;\n      if (this.isStopped || this.isLocked) return void i.preventDefault();\n      if (this.isSmooth = this.options.syncTouch && s || this.options.smoothWheel && o, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n      i.preventDefault();\n      let h = e;\n      \"both\" === this.options.gestureOrientation ? h = Math.abs(e) > Math.abs(t) ? e : t : \"horizontal\" === this.options.gestureOrientation && (h = t);\n      const a = s && this.options.syncTouch,\n        c = s && \"touchend\" === i.type && Math.abs(h) > 5;\n      c && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, {\n        programmatic: !1,\n        ...(a ? {\n          lerp: c ? this.options.syncTouchLerp : 1\n        } : {\n          lerp: this.options.lerp,\n          duration: this.options.duration,\n          easing: this.options.easing\n        })\n      });\n    });\n    _defineProperty(this, \"onNativeScroll\", () => {\n      if (!this.__preventNextScrollEvent && !this.isScrolling) {\n        const t = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n      }\n    });\n    window.lenisVersion = \"1.0.34\", _t2 !== document.documentElement && _t2 !== document.body || (_t2 = window), this.options = {\n      wrapper: _t2,\n      content: _e2,\n      wheelEventsTarget: _i2,\n      eventsTarget: _s2,\n      smoothWheel: _o,\n      syncTouch: _n,\n      syncTouchLerp: _r,\n      touchInertiaMultiplier: _l,\n      duration: _h,\n      easing: _a,\n      lerp: _c,\n      infinite: p,\n      gestureOrientation: d,\n      orientation: u,\n      touchMultiplier: m,\n      wheelMultiplier: g,\n      normalizeWheel: v,\n      autoResize: S\n    }, this.animate = new Animate(), this.emitter = new Emitter(), this.dimensions = new Dimensions({\n      wrapper: _t2,\n      content: _e2,\n      autoResize: S\n    }), this.toggleClass(\"lenis\", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = _n || _o, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll = new VirtualScroll(_s2, {\n      touchMultiplier: m,\n      wheelMultiplier: g,\n      normalizeWheel: v\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass(\"lenis\", !1), this.toggleClass(\"lenis-smooth\", !1), this.toggleClass(\"lenis-scrolling\", !1), this.toggleClass(\"lenis-stopped\", !1), this.toggleClass(\"lenis-locked\", !1);\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  off(t, e) {\n    return this.emitter.off(t, e);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const e = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * e);\n  }\n  scrollTo(e) {\n    let {\n      offset: i = 0,\n      immediate: s = !1,\n      lock: o = !1,\n      duration: n = this.options.duration,\n      easing: r = this.options.easing,\n      lerp: l = !n && this.options.lerp,\n      onComplete: h = null,\n      force: a = !1,\n      programmatic: c = !0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.isStopped && !this.isLocked || a) {\n      if ([\"top\", \"left\", \"start\"].includes(e)) e = 0;else if ([\"bottom\", \"right\", \"end\"].includes(e)) e = this.limit;else {\n        var _e3;\n        let t;\n        if (\"string\" == typeof e ? t = document.querySelector(e) : ((_e3 = e) === null || _e3 === void 0 ? void 0 : _e3.nodeType) && (t = e), t) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            i -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = t.getBoundingClientRect();\n          e = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof e) {\n        if (e += i, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = t(0, e, this.limit), s) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void (h === null || h === void 0 ? void 0 : h(this));\n        if (!c) {\n          if (e === this.targetScroll) return;\n          this.targetScroll = e;\n        }\n        this.animate.fromTo(this.animatedScroll, e, {\n          duration: n,\n          easing: r,\n          lerp: l,\n          onStart: () => {\n            o && (this.isLocked = !0), this.isScrolling = !0;\n          },\n          onUpdate: (t, e) => {\n            this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), h !== null && h !== void 0 && h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {\n              delete this.__preventNextScrollEvent;\n            }));\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (t = this.animatedScroll, e = this.limit, (t % e + e) % e) : this.animatedScroll;\n    var t, e;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClass(\"lenis-smooth\", t));\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClass(\"lenis-scrolling\", t));\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.__isStopped = t, this.toggleClass(\"lenis-stopped\", t));\n  }\n  get isLocked() {\n    return this.__isLocked;\n  }\n  set isLocked(t) {\n    this.__isLocked !== t && (this.__isLocked = t, this.toggleClass(\"lenis-locked\", t));\n  }\n  get className() {\n    let t = \"lenis\";\n    return this.isStopped && (t += \" lenis-stopped\"), this.isLocked && (t += \" lenis-locked\"), this.isScrolling && (t += \" lenis-scrolling\"), this.isSmooth && (t += \" lenis-smooth\"), t;\n  }\n  toggleClass(t, e) {\n    this.rootElement.classList.toggle(t, e), this.emitter.emit(\"className change\", this);\n  }\n}\nexport { Lenis as default };","map":{"version":3,"names":["t","e","i","Math","max","min","Animate","advance","_this$onUpdate","isRunning","lerp","value","s","o","to","n","r","exp","round","currentTime","duration","easing","from","onUpdate","call","stop","fromTo","_ref","onStart","Dimensions","constructor","wrapper","content","autoResize","arguments","length","undefined","_defineProperty","onWrapperResize","onContentResize","window","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","clearTimeout","setTimeout","apply","resize","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","_this$wrapperResizeOb","_this$contentResizeOb","disconnect","limit","x","y","Emitter","events","emit","_len","Array","_key","on","_this$events$t","push","_this$events$t2","filter","off","_this$events$t3","VirtualScroll","_ref2","wheelMultiplier","touchMultiplier","normalizeWheel","clientX","clientY","targetTouches","touchStart","lastDelta","emitter","deltaX","deltaY","event","element","addEventListener","onWheel","passive","onTouchStart","onTouchMove","onTouchEnd","removeEventListener","Lenis","document","documentElement","wheelEventsTarget","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaMultiplier","l","h","a","pow","c","infinite","p","orientation","u","gestureOrientation","d","m","g","v","S","_ref3","ctrlKey","type","includes","options","reset","composedPath","slice","indexOf","rootElement","find","_t$hasAttribute","_t$hasAttribute2","_t$hasAttribute3","_t$classList","hasAttribute","classList","contains","isStopped","isLocked","preventDefault","isSmooth","isScrolling","animate","abs","velocity","scrollTo","targetScroll","programmatic","__preventNextScrollEvent","animatedScroll","actualScroll","direction","sign","lenisVersion","body","dimensions","toggleClass","onNativeScroll","virtualScroll","onVirtualScroll","setScroll","isHorizontal","scrollLeft","scrollTop","start","raf","time","offset","immediate","lock","onComplete","force","_e3","querySelector","nodeType","getBoundingClientRect","left","top","scroll","requestAnimationFrame","progress","__isSmooth","__isScrolling","__isStopped","__isLocked","className","toggle","default"],"sources":["/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/maths.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/animate.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/dimensions.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/debounce.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/emitter.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/virtual-scroll.js","/Users/apple/Downloads/VisShon/website/node_modules/@studio-freight/lenis/src/index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\nexport function clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max))\n}\n\n// Truncate a floating-point number to a specified number of decimal places\nexport function truncate(value, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\nexport function lerp(x, y, t) {\n  return (1 - t) * x + t * y\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nexport function damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\n}\n\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n// https://anguscroll.com/just/just-modulo\nexport function modulo(n, d) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\n\n// Animate class to handle value animations with lerping or easing\nexport class Animate {\n  // Advance the animation by the given delta time\n  advance(deltaTime) {\n    if (!this.isRunning) return\n\n    let completed = false\n\n    if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to\n        completed = true\n      }\n    } else {\n      this.currentTime += deltaTime\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\n\n      completed = linearProgress >= 1\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\n      this.value = this.from + (this.to - this.from) * easedProgress\n    }\n\n    // Call the onUpdate callback with the current value and completed status\n    this.onUpdate?.(this.value, completed)\n\n    if (completed) {\n      this.stop()\n    }\n  }\n\n  // Stop the animation\n  stop() {\n    this.isRunning = false\n  }\n\n  // Set up the animation from a starting value to an ending value\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\n  fromTo(\n    from,\n    to,\n    { lerp = 0.1, duration = 1, easing = (t) => t, onStart, onUpdate }\n  ) {\n    this.from = this.value = from\n    this.to = to\n    this.lerp = lerp\n    this.duration = duration\n    this.easing = easing\n    this.currentTime = 0\n    this.isRunning = true\n\n    onStart?.()\n    this.onUpdate = onUpdate\n  }\n}\n","import { debounce } from './debounce'\n\nexport class Dimensions {\n  constructor({ wrapper, content, autoResize = true } = {}) {\n    this.wrapper = wrapper\n    this.content = content\n\n    if (autoResize) {\n      const resize = debounce(this.resize, 250)\n\n      if (this.wrapper !== window) {\n        this.wrapperResizeObserver = new ResizeObserver(resize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(resize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper === window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    this.scrollHeight = this.content.scrollHeight\n    this.scrollWidth = this.content.scrollWidth\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","export function debounce(callback, delay) {\n  let timer\n  return function () {\n    let args = arguments\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","export class Emitter {\n  constructor() {\n    this.events = {}\n  }\n\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  }\n\n  on(event, cb) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\nimport { clamp } from './maths'\n\nexport class VirtualScroll {\n  constructor(\n    element,\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\n  ) {\n    this.element = element\n    this.wheelMultiplier = wheelMultiplier\n    this.touchMultiplier = touchMultiplier\n    this.normalizeWheel = normalizeWheel\n\n    this.touchStart = {\n      x: null,\n      y: null,\n    }\n\n    this.emitter = new Emitter()\n\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\n    this.element.addEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.addEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.addEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Add an event listener for the given event and callback\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  // Remove all event listeners and clean up\n  destroy() {\n    this.emitter.destroy()\n\n    this.element.removeEventListener('wheel', this.onWheel, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\n      passive: false,\n    })\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\n      passive: false,\n    })\n  }\n\n  // Event handler for 'touchstart' event\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: 0,\n      y: 0,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX: 0,\n      deltaY: 0,\n      event,\n    })\n  }\n\n  // Event handler for 'touchmove' event\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches\n      ? event.targetTouches[0]\n      : event\n\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\n\n    this.touchStart.x = clientX\n    this.touchStart.y = clientY\n\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY,\n    }\n\n    this.emitter.emit('scroll', {\n      deltaX,\n      deltaY,\n      event,\n    })\n  }\n\n  onTouchEnd = (event) => {\n    this.emitter.emit('scroll', {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event,\n    })\n  }\n\n  // Event handler for 'wheel' event\n  onWheel = (event) => {\n    let { deltaX, deltaY } = event\n\n    if (this.normalizeWheel) {\n      deltaX = clamp(-100, deltaX, 100)\n      deltaY = clamp(-100, deltaY, 100)\n    }\n\n    deltaX *= this.wheelMultiplier\n    deltaY *= this.wheelMultiplier\n\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\n  }\n}\n","import { version } from '../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\nexport default class Lenis {\n  // isScrolling = true when scroll is animating\n  // isStopped = true if user should not be able to scroll - enable/disable programmatically\n  // isSmooth = true if scroll should be animated\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\n\n  /**\n   * @typedef {(t: number) => number} EasingFunction\n   * @typedef {'vertical' | 'horizontal'} Orientation\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\n   *\n   * @typedef LenisOptions\n   * @property {Window | HTMLElement} [wrapper]\n   * @property {HTMLElement} [content]\n   * @property {Window | HTMLElement} [wheelEventsTarget] // deprecated\n   * @property {Window | HTMLElement} [eventsTarget]\n   * @property {boolean} [smoothWheel]\n   * @property {boolean} [syncTouch]\n   * @property {number} [syncTouchLerp]\n  //  * @property {number} [__iosNoInertiaSyncTouchLerp]\n   * @property {number} [touchInertiaMultiplier]\n   * @property {number} [duration]\n   * @property {EasingFunction} [easing]\n   * @property {number} [lerp]\n   * @property {boolean} [infinite]\n   * @property {Orientation} [orientation]\n   * @property {GestureOrientation} [gestureOrientation]\n   * @property {number} [touchMultiplier]\n   * @property {number} [wheelMultiplier]\n   * @property {boolean} [normalizeWheel] \n   * @property {boolean} [autoResize]\n   *\n   * @param {LenisOptions}\n   */\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    wheelEventsTarget = wrapper, // deprecated\n    eventsTarget = wheelEventsTarget,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    // __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\n    touchInertiaMultiplier = 35,\n    duration, // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp = !duration && 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    normalizeWheel = false, // deprecated\n    autoResize = true,\n  } = {}) {\n    window.lenisVersion = version\n\n    // if wrapper is html or body, fallback to window\n    if (wrapper === document.documentElement || wrapper === document.body) {\n      wrapper = window\n    }\n\n    this.options = {\n      wrapper,\n      content,\n      wheelEventsTarget,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      // __iosNoInertiaSyncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n      autoResize,\n    }\n\n    this.animate = new Animate()\n    this.emitter = new Emitter()\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\n    this.toggleClass('lenis', true)\n\n    this.velocity = 0\n    this.isLocked = false\n    this.isStopped = false\n    this.isSmooth = syncTouch || smoothWheel\n    this.isScrolling = false\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier,\n      normalizeWheel,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n  }\n\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener('scroll', this.onNativeScroll, {\n      passive: false,\n    })\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.toggleClass('lenis', false)\n    this.toggleClass('lenis-smooth', false)\n    this.toggleClass('lenis-scrolling', false)\n    this.toggleClass('lenis-stopped', false)\n    this.toggleClass('lenis-locked', false)\n  }\n\n  on(event, callback) {\n    return this.emitter.on(event, callback)\n  }\n\n  off(event, callback) {\n    return this.emitter.off(event, callback)\n  }\n\n  setScroll(scroll) {\n    // apply scroll value immediately\n    if (this.isHorizontal) {\n      this.rootElement.scrollLeft = scroll\n    } else {\n      this.rootElement.scrollTop = scroll\n    }\n  }\n\n  onVirtualScroll = ({ deltaX, deltaY, event }) => {\n    // keep zoom feature\n    if (event.ctrlKey) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    const isTapToStop =\n      this.options.syncTouch && isTouch && event.type === 'touchstart'\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    const isClick = deltaX === 0 && deltaY === 0 // click event\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClick || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node.hasAttribute?.('data-lenis-prevent') ||\n          (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n          (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n          node.classList?.contains('lenis') // nested lenis instance\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault()\n      return\n    }\n\n    this.isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!this.isSmooth) {\n      this.isScrolling = false\n      this.animate.stop()\n      return\n    }\n\n    event.preventDefault()\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    const syncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\n\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(syncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  resize() {\n    this.dimensions.resize()\n  }\n\n  emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  onNativeScroll = () => {\n    if (this.__preventNextScrollEvent) return\n\n    if (!this.isScrolling) {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.velocity = 0\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\n      this.emit()\n    }\n  }\n\n  reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.velocity = 0\n    this.animate.stop()\n  }\n\n  start() {\n    this.isStopped = false\n\n    this.reset()\n  }\n\n  stop() {\n    this.isStopped = true\n    this.animate.stop()\n\n    this.reset()\n  }\n\n  raf(time) {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n  }\n\n  scrollTo(\n    target,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      duration = this.options.duration,\n      easing = this.options.easing,\n      lerp = !duration && this.options.lerp,\n      onComplete = null,\n      force = false, // scroll even if stopped\n      programmatic = true, // called from outside of the class\n    } = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (['top', 'left', 'start'].includes(target)) {\n      target = 0\n    } else if (['bottom', 'right', 'end'].includes(target)) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n      } else if (target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      onComplete?.(this)\n      return\n    }\n\n    if (!programmatic) {\n      if (target === this.targetScroll) return\n\n      this.targetScroll = target\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = true\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = true\n\n        // updated\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity)\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n\n          // avoid emitting event twice\n          this.__preventNextScrollEvent = true\n          requestAnimationFrame(() => {\n            delete this.__preventNextScrollEvent\n          })\n        }\n      },\n    })\n  }\n\n  get rootElement() {\n    return this.options.wrapper === window\n      ? document.documentElement\n      : this.options.wrapper\n  }\n\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n  }\n\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  get actualScroll() {\n    // value browser takes into account\n    return this.isHorizontal\n      ? this.rootElement.scrollLeft\n      : this.rootElement.scrollTop\n  }\n\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  get isSmooth() {\n    return this.__isSmooth\n  }\n\n  set isSmooth(value) {\n    if (this.__isSmooth !== value) {\n      this.__isSmooth = value\n      this.toggleClass('lenis-smooth', value)\n    }\n  }\n\n  get isScrolling() {\n    return this.__isScrolling\n  }\n\n  set isScrolling(value) {\n    if (this.__isScrolling !== value) {\n      this.__isScrolling = value\n      this.toggleClass('lenis-scrolling', value)\n    }\n  }\n\n  get isStopped() {\n    return this.__isStopped\n  }\n\n  set isStopped(value) {\n    if (this.__isStopped !== value) {\n      this.__isStopped = value\n      this.toggleClass('lenis-stopped', value)\n    }\n  }\n\n  get isLocked() {\n    return this.__isLocked\n  }\n\n  set isLocked(value) {\n    if (this.__isLocked !== value) {\n      this.__isLocked = value\n      this.toggleClass('lenis-locked', value)\n    }\n  }\n\n  get className() {\n    let className = 'lenis'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isSmooth) className += ' lenis-smooth'\n    return className\n  }\n\n  toggleClass(name, value) {\n    this.rootElement.classList.toggle(name, value)\n    this.emitter.emit('className change', this)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}